import React, { useState, useCallback } from 'react';
import { jsPDF } from 'jspdf';

// Define the interfaces for the props
interface Speaker {
  name: string;
  voice: string;
  gender: string;
}

interface Slide {
  title: string;
  speaker: string;
  content?: string;
  content2?: string;
  narration?: string;
  visualDuration?: number;
  isComplex: boolean;
  visual?: {
    type: string;
    params?: string[];
  };
}

interface Project {
  title: string;
  projectId: string;
  speakers: Record<string, Speaker>;
}

interface PDFExportButtonProps {
  project: Project;
  slides: Slide[];
  filename: string;
}

const PDFExportButton: React.FC<PDFExportButtonProps> = ({ project, slides, filename }) => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const generateAndDownloadPDF = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = 210;
      const pageHeight = 297;
      const margin = 20;
      const contentWidth = pageWidth - margin * 2;

      // --- Helper function implementations ---

      const calculateTotalDuration = (): number => {
        return slides.reduce((total, slide) => total + (slide.visualDuration || 0), 0);
      };

      const getUniqueVisualFunctions = (): string[] => {
        const visualFuncs = slides
          .map(slide => slide.visual?.type)
          .filter((type): type is string => !!type);
        return [...new Set(visualFuncs)];
      };

      const getProjectTitle = (): string => {
        return project?.title || slides[0]?.title || 'Educational Script';
      };

      const addPDFFooter = (pageNumber: number, totalPages: number) => {
        const footerY = pageHeight - 15;
        pdf.setFontSize(8);
        pdf.setTextColor(150, 150, 150);
        
        // Page number
        const pageNumText = `Page ${pageNumber} of ${totalPages}`;
        pdf.text(pageNumText, pageWidth - margin, footerY, { align: 'right' });

        // Generated by text
        pdf.text('Generated by Educational Video Generator', margin, footerY);
      };

      const drawInfoBox = (yPos: number) => {
        const boxHeight = 40;
        pdf.setLineWidth(0.5);
        pdf.setDrawColor(220, 220, 220);
        pdf.setFillColor(248, 249, 250);
        pdf.rect(margin, yPos, contentWidth, boxHeight, 'FD');

        yPos += 10;
        pdf.setFontSize(11);
        pdf.setFont('bold');
        pdf.setTextColor(0, 0, 0);

        const projectInfo = [
          `Project ID: ${project?.projectId?.substring(0, 8) || 'N/A'}`,
          `Total Slides: ${slides.length}`,
          `Generated: ${new Date().toLocaleDateString()}`,
          `Est. Duration: ${calculateTotalDuration()}s`
        ];

        projectInfo.forEach((info, index) => {
          const x = margin + 10 + (index % 2) * (contentWidth / 2 - 10);
          const y = yPos + Math.floor(index / 2) * 10;
          pdf.text(info, x, y);
        });
      };
      
      const addSpeakersSection = (yPos: number) => {
        pdf.setFontSize(14);
        pdf.setFont('bold');
        pdf.text('Speakers', margin, yPos);
        yPos += 10;
        
        pdf.setFontSize(11);
        pdf.setFont('bold');

        if (project?.speakers && Object.keys(project.speakers).length > 0) {
          Object.entries(project.speakers).forEach(([key, speaker]) => {
            pdf.text(`â€¢ ${speaker.name || key} (Voice: ${speaker.voice || 'default'})`, margin + 5, yPos);
            yPos += 7;
          });
        } else {
          pdf.text('â€¢ No speaker information available', margin + 5, yPos);
        }
      };

      const addTitlePage = () => {
        let yPos = 60;
        const centerX = pageWidth / 2;

        pdf.setFontSize(24);
        pdf.setFont('bold');
        pdf.text(getProjectTitle(), centerX, yPos, { align: 'center' });
        yPos += 20;

        pdf.setFontSize(16);
        pdf.setFont('normal');
        pdf.text('Educational Video Script', centerX, yPos, { align: 'center' });
        yPos += 30;

        drawInfoBox(yPos);
        yPos += 60;

        addSpeakersSection(yPos);
      };

      const checkPageEndAndAdd = (yPos: number, pageNum: number, totalPages: number): number => {
          const requiredSpace = 30; // space for footer + a little margin
          if (yPos > pageHeight - requiredSpace) {
              addPDFFooter(pageNum, totalPages);
              pdf.addPage();
              return margin; // Reset yPos for the new page
          }
          return yPos;
      };

      const addTextSection = (yPos: number, title: string, text: string | undefined, options: { isItalic?: boolean } = {}): number => {
        if (!text) return yPos;

        let newY = yPos;
        pdf.setFontSize(12);
        pdf.setFont('bold');
        pdf.text(title, margin, newY);
        newY += 7;

        pdf.setFontSize(11);
        pdf.setFont(options.isItalic ? 'italic' : 'normal');
        if(options.isItalic) pdf.setTextColor(60, 60, 60);

        const lines = pdf.splitTextToSize(text, contentWidth - 5);
        pdf.text(lines, margin + 5, newY);
        newY += lines.length * 5.5 + 8;
        
        pdf.setTextColor(0, 0, 0); // Reset color
        pdf.setFont('normal');
        return newY;
      }
      
      const addSlidePage = (slide: Slide, slideNumber: number, totalPages: number) => {
        let yPos = margin;
        
        // Header
        pdf.setFontSize(16);
        pdf.setFont('bold');
        pdf.setTextColor(26, 82, 118);
        pdf.text(`Slide ${slideNumber}`, margin, yPos);

        const speakerName = project?.speakers?.[slide.speaker]?.name || slide.speaker;
        pdf.setFontSize(10);
        pdf.setFont('normal');
        pdf.setTextColor(100, 100, 100);
        pdf.text(`Speaker: ${speakerName}`, pageWidth - margin, yPos, { align: 'right' });
        yPos += 15;
        
        pdf.setTextColor(0, 0, 0);

        // Title
        pdf.setFontSize(14);
        pdf.setFont('bold');
        const titleLines = pdf.splitTextToSize(slide.title || 'Untitled', contentWidth);
        pdf.text(titleLines, margin, yPos);
        yPos += titleLines.length * 7 + 10;
        
        yPos = checkPageEndAndAdd(yPos, slideNumber, totalPages);

        // Content
        yPos = addTextSection(yPos, 'Content:', slide.content);
        yPos = addTextSection(yPos, 'Additional Content:', slide.content2);
        yPos = addTextSection(yPos, 'Narration:', slide.narration, { isItalic: true });
        
        yPos = checkPageEndAndAdd(yPos, slideNumber, totalPages);

        // Visual Info
        if (slide.visual?.type) {
            pdf.setFontSize(10);
            pdf.setFont('bold');
            pdf.setTextColor(231, 76, 60);
            pdf.text('ðŸŽ¨ Visual Function:', margin, yPos);
            yPos += 7;
            
            pdf.setFont('normal');
            pdf.setTextColor(0, 0, 0);
            const visualInfo = `${slide.visual.type}(${slide.visual.params ? slide.visual.params.join(', ') : ''})`;
            const visualLines = pdf.splitTextToSize(visualInfo, contentWidth - 10);
            pdf.text(visualLines, margin + 5, yPos);
            yPos += visualLines.length * 5 + 8;
        }

        // Technical details line at the bottom
        const footerY = pageHeight - 20;
        pdf.setLineWidth(0.2);
        pdf.setDrawColor(200, 200, 200);
        pdf.line(margin, footerY - 5, pageWidth - margin, footerY - 5);

        pdf.setFontSize(9);
        pdf.setFont('normal');
        pdf.setTextColor(100, 100, 100);
        const techDetails = `Duration: ${slide.visualDuration || 'N/A'}s  |  Complex: ${slide.isComplex ? 'Yes' : 'No'}`;
        pdf.text(techDetails, margin, footerY);
      };
      
      const addSummaryPage = () => {
        pdf.addPage();
        let yPos = margin;
        
        pdf.setFontSize(18);
        pdf.setFont('bold');
        pdf.text('Script Summary & Statistics', pageWidth / 2, yPos, { align: 'center' });
        yPos += 25;

        // Statistics
        const stats = [
          `Total Slides: ${slides.length}`,
          `Total Speakers: ${Object.keys(project?.speakers || {}).length}`,
          `Unique Visual Functions: ${getUniqueVisualFunctions().length}`,
          `Estimated Total Duration: ${calculateTotalDuration()}s`,
          `Complex Slides: ${slides.filter(s => s.isComplex).length}`,
          `Average Slide Duration: ${(slides.length > 0 ? calculateTotalDuration() / slides.length : 0).toFixed(1)}s`
        ];
        yPos = addTextSection(yPos, 'ðŸ“Š Project Statistics', stats.join('\nâ€¢ '), {isItalic: false});
        yPos += 10;
        
        // Visual Functions List
        const visualFunctions = getUniqueVisualFunctions();
        if (visualFunctions.length > 0) {
            yPos = addTextSection(yPos, 'ðŸŽ¨ Visual Functions Used', visualFunctions.join('\nâ€¢ '));
            yPos += 10;
        }

        // Speaker Breakdown
        const speakerCounts: Record<string, number> = {};
        slides.forEach(slide => {
          speakerCounts[slide.speaker] = (speakerCounts[slide.speaker] || 0) + 1;
        });
        const breakdown = Object.entries(speakerCounts).map(([speaker, count]) => {
          const speakerName = project?.speakers?.[speaker]?.name || speaker;
          const percentage = ((count / slides.length) * 100).toFixed(1);
          return `${speakerName}: ${count} slides (${percentage}%)`;
        });

        yPos = addTextSection(yPos, 'ðŸ‘¥ Speaker Breakdown', breakdown.join('\nâ€¢ '));
      };


      // --- PDF Generation Logic ---
      const totalPages = slides.length + 2; // Title + Slides + Summary

      // 1. Add Title Page
      addTitlePage();
      addPDFFooter(1, totalPages);

      // 2. Add Slide Pages
      slides.forEach((slide, i) => {
        pdf.addPage();
        addSlidePage(slide, i + 1, totalPages);
        addPDFFooter(i + 2, totalPages);
      });

      // 3. Add Summary Page
      addSummaryPage();
      addPDFFooter(totalPages, totalPages);

      pdf.save(filename);

    } catch (err) {
      setError('Failed to generate PDF. Please try again.');
      console.error(err);
    } finally {
      setLoading(false);
    }
  }, [project, slides, filename]);

  return (
    <div>
      <button onClick={generateAndDownloadPDF} disabled={loading}>
        {loading ? 'Generating PDF...' : 'Export to PDF'}
      </button>
      {error && <p style={{ color: 'red' }}>{error}</p>}
    </div>
  );
};

export default PDFExportButton;