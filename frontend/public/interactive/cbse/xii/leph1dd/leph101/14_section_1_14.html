<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Gauss's Law Applications</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 1s ease-out;
        }

        .header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .tab {
            padding: 15px 25px;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            font-weight: 600;
        }

        .tab:hover, .tab.active {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .content.active {
            display: block;
        }

        .simulation-container {
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .canvas-container {
            position: relative;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin: 20px 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            border-radius: 15px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .control-group {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
        }

        .control-group h3 {
            margin-bottom: 15px;
            color: #ffeb3b;
        }

        .slider-container {
            margin: 15px 0;
        }

        .slider-container label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: rgba(255,255,255,0.3);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffeb3b;
            cursor: pointer;
        }

        .value-display {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 12px;
            border-radius: 20px;
            margin-left: 10px;
            font-weight: bold;
        }

        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255,107,107,0.4);
        }

        .formula-box {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border-left: 5px solid #ffeb3b;
        }

        .formula-box h3 {
            color: #ffeb3b;
            margin-bottom: 10px;
        }

        .math-display {
            font-size: 1.2em;
            font-family: 'Times New Roman', serif;
            text-align: center;
            margin: 10px 0;
        }

        .info-panel {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .quiz-container {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .quiz-question {
            margin-bottom: 15px;
        }

        .quiz-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .quiz-option {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .quiz-option:hover {
            background: rgba(255,255,255,0.2);
        }

        .quiz-option.correct {
            border-color: #4caf50;
            background: rgba(76,175,80,0.3);
        }

        .quiz-option.incorrect {
            border-color: #f44336;
            background: rgba(244,67,54,0.3);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-50px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        .field-vector {
            stroke: #ffeb3b;
            stroke-width: 2;
            fill: #ffeb3b;
        }

        .charge-positive {
            fill: #ff4444;
            stroke: #ffffff;
            stroke-width: 2;
        }

        .charge-negative {
            fill: #4444ff;
            stroke: #ffffff;
            stroke-width: 2;
        }

        .gaussian-surface {
            fill: none;
            stroke: #00ff00;
            stroke-width: 3;
            stroke-dasharray: 5,5;
            opacity: 0.8;
        }

        .responsive-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üî¨ Interactive Gauss's Law Applications</h1>
            <p>Explore electric fields through interactive simulations and visualizations</p>
        </div>

        <div class="tabs">
            <button class="tab active" onclick="showTab('wire')">‚ö° Infinite Wire</button>
            <button class="tab" onclick="showTab('sheet')">üìã Plane Sheet</button>
            <button class="tab" onclick="showTab('shell')">üåê Spherical Shell</button>
            <button class="tab" onclick="showTab('atom')">‚öõÔ∏è Atomic Model</button>
            <button class="tab" onclick="showTab('quiz')">üß† Quiz</button>
        </div>

        <!-- Infinite Wire Section -->
        <div id="wire" class="content active">
            <div class="simulation-container">
                <h2>‚ö° Electric Field of an Infinite Charged Wire</h2>
                
                <div class="responsive-grid">
                    <div>
                        <div class="canvas-container">
                            <canvas id="wireCanvas" width="500" height="400"></canvas>
                        </div>
                        
                        <div class="controls">
                            <div class="control-group">
                                <h3>Wire Properties</h3>
                                <div class="slider-container">
                                    <label>Linear Charge Density (Œª): <span class="value-display" id="lambdaValue">5.0</span> nC/m</label>
                                    <input type="range" id="lambdaSlider" min="-10" max="10" step="0.5" value="5">
                                </div>
                                <button class="btn" onclick="animateFieldLines('wire')">üéØ Show Field Animation</button>
                                <button class="btn" onclick="toggleGaussianSurface('wire')">üìê Toggle Gaussian Surface</button>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="formula-box">
                            <h3>üìê Gauss's Law Application</h3>
                            <div class="math-display">
                                E = Œª / (2œÄŒµ‚ÇÄr)
                            </div>
                            <p>For an infinite wire with linear charge density Œª, the electric field at distance r is:</p>
                            <div id="wireFieldValue" class="math-display">E = 0 N/C</div>
                        </div>
                        
                        <div class="info-panel">
                            <h3>üîç Observation Point</h3>
                            <p>Click on the canvas to place an observation point and see the electric field calculation!</p>
                            <div id="wirePointInfo">Select a point to see field details</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Plane Sheet Section -->
        <div id="sheet" class="content">
            <div class="simulation-container">
                <h2>üìã Electric Field of an Infinite Charged Plane Sheet</h2>
                
                <div class="responsive-grid">
                    <div>
                        <div class="canvas-container">
                            <canvas id="sheetCanvas" width="500" height="400"></canvas>
                        </div>
                        
                        <div class="controls">
                            <div class="control-group">
                                <h3>Sheet Properties</h3>
                                <div class="slider-container">
                                    <label>Surface Charge Density (œÉ): <span class="value-display" id="sigmaValue">3.0</span> nC/m¬≤</label>
                                    <input type="range" id="sigmaSlider" min="-10" max="10" step="0.5" value="3">
                                </div>
                                <button class="btn" onclick="animateFieldLines('sheet')">üéØ Show Field Animation</button>
                                <button class="btn" onclick="toggleGaussianSurface('sheet')">üìê Toggle Gaussian Surface</button>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="formula-box">
                            <h3>üìê Gauss's Law Application</h3>
                            <div class="math-display">
                                E = œÉ / (2Œµ‚ÇÄ)
                            </div>
                            <p>For an infinite sheet with surface charge density œÉ, the electric field is uniform:</p>
                            <div id="sheetFieldValue" class="math-display">E = 0 N/C</div>
                        </div>
                        
                        <div class="info-panel">
                            <h3>üîç Key Insight</h3>
                            <p>The electric field is <strong>independent of distance</strong> from the sheet!</p>
                            <div id="sheetPointInfo">Field is uniform everywhere</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Spherical Shell Section -->
        <div id="shell" class="content">
            <div class="simulation-container">
                <h2>üåê Electric Field of a Charged Spherical Shell</h2>
                
                <div class="responsive-grid">
                    <div>
                        <div class="canvas-container">
                            <canvas id="shellCanvas" width="500" height="400"></canvas>
                        </div>
                        
                        <div class="controls">
                            <div class="control-group">
                                <h3>Shell Properties</h3>
                                <div class="slider-container">
                                    <label>Total Charge (Q): <span class="value-display" id="chargeValue">10.0</span> nC</label>
                                    <input type="range" id="chargeSlider" min="-20" max="20" step="1" value="10">
                                </div>
                                <div class="slider-container">
                                    <label>Shell Radius (R): <span class="value-display" id="radiusValue">50</span> pixels</label>
                                    <input type="range" id="radiusSlider" min="30" max="100" step="5" value="50">
                                </div>
                                <button class="btn" onclick="animateFieldLines('shell')">üéØ Show Field Animation</button>
                                <button class="btn" onclick="toggleGaussianSurface('shell')">üìê Toggle Gaussian Surface</button>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="formula-box">
                            <h3>üìê Gauss's Law Application</h3>
                            <div class="math-display">
                                Outside (r > R): E = Q / (4œÄŒµ‚ÇÄr¬≤)<br>
                                Inside (r < R): E = 0
                            </div>
                            <div id="shellFieldValue" class="math-display">Click to see field value</div>
                        </div>
                        
                        <div class="info-panel">
                            <h3>üîç Observation Point</h3>
                            <p>Click inside or outside the shell to see different field behaviors!</p>
                            <div id="shellPointInfo">Select a point to see field details</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Atomic Model Section -->
        <div id="atom" class="content">
            <div class="simulation-container">
                <h2>‚öõÔ∏è Early Atomic Model - Thomson's Model</h2>
                
                <div class="responsive-grid">
                    <div>
                        <div class="canvas-container">
                            <canvas id="atomCanvas" width="500" height="400"></canvas>
                        </div>
                        
                        <div class="controls">
                            <div class="control-group">
                                <h3>Atomic Properties</h3>
                                <div class="slider-container">
                                    <label>Nuclear Charge (Ze): <span class="value-display" id="nuclearChargeValue">10</span></label>
                                    <input type="range" id="nuclearChargeSlider" min="1" max="20" step="1" value="10">
                                </div>
                                <div class="slider-container">
                                    <label>Atom Radius (R): <span class="value-display" id="atomRadiusValue">80</span> pixels</label>
                                    <input type="range" id="atomRadiusSlider" min="50" max="120" step="5" value="80">
                                </div>
                                <button class="btn" onclick="animateFieldLines('atom')">üéØ Show Field Lines</button>
                                <button class="btn" onclick="showFieldGraph()">üìä Show Field Graph</button>
                            </div>
                        </div>
                    </div>
                    
                    <div>
                        <div class="formula-box">
                            <h3>üìê Field Equations</h3>
                            <div class="math-display">
                                Inside (r < R): E = (Ze/4œÄŒµ‚ÇÄ) √ó (1/r¬≤ - r/R¬≥)<br>
                                Outside (r > R): E = 0
                            </div>
                            <div id="atomFieldValue" class="math-display">Click to see field value</div>
                        </div>
                        
                        <div class="info-panel">
                            <h3>üîç Thomson's Model</h3>
                            <p>Positive nucleus surrounded by uniform negative charge density. The atom is overall neutral!</p>
                            <div id="atomPointInfo">Click to explore the field</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quiz Section -->
        <div id="quiz" class="content">
            <div class="quiz-container">
                <h2>üß† Test Your Understanding</h2>
                <div id="quizContent">
                    <!-- Quiz questions will be loaded here -->
                </div>
                <button class="btn" onclick="loadQuiz()">üéØ Start Quiz</button>
                <div id="quizResults"></div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let activeCanvas = null;
        let showGaussian = false;
        let animating = false;
        let currentTab = 'wire';

        // Physical constants
        const k = 8.99e9; // Coulomb's constant
        const epsilon0 = 8.85e-12;

        // Canvas contexts
        const canvases = {
            wire: null,
            sheet: null,
            shell: null,
            atom: null
        };

        // Initialize when page loads
        window.onload = function() {
            initializeCanvases();
            setupEventListeners();
            updateWireSimulation();
        };

        function initializeCanvases() {
            canvases.wire = document.getElementById('wireCanvas').getContext('2d');
            canvases.sheet = document.getElementById('sheetCanvas').getContext('2d');
            canvases.shell = document.getElementById('shellCanvas').getContext('2d');
            canvases.atom = document.getElementById('atomCanvas').getContext('2d');
        }

        function setupEventListeners() {
            // Wire simulation
            document.getElementById('lambdaSlider').addEventListener('input', updateWireSimulation);
            document.getElementById('wireCanvas').addEventListener('click', handleWireClick);

            // Sheet simulation
            document.getElementById('sigmaSlider').addEventListener('input', updateSheetSimulation);
            document.getElementById('sheetCanvas').addEventListener('click', handleSheetClick);

            // Shell simulation
            document.getElementById('chargeSlider').addEventListener('input', updateShellSimulation);
            document.getElementById('radiusSlider').addEventListener('input', updateShellSimulation);
            document.getElementById('shellCanvas').addEventListener('click', handleShellClick);

            // Atom simulation
            document.getElementById('nuclearChargeSlider').addEventListener('input', updateAtomSimulation);
            document.getElementById('atomRadiusSlider').addEventListener('input', updateAtomSimulation);
            document.getElementById('atomCanvas').addEventListener('click', handleAtomClick);
        }

        function showTab(tabName) {
            // Hide all content
            const contents = document.querySelectorAll('.content');
            contents.forEach(content => content.classList.remove('active'));

            // Show selected content
            document.getElementById(tabName).classList.add('active');

            // Update tab buttons
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            currentTab = tabName;
            
            // Update the corresponding simulation
            switch(tabName) {
                case 'wire': updateWireSimulation(); break;
                case 'sheet': updateSheetSimulation(); break;
                case 'shell': updateShellSimulation(); break;
                case 'atom': updateAtomSimulation(); break;
                case 'quiz': loadQuiz(); break;
            }
        }

        // Wire Simulation Functions
        function updateWireSimulation() {
            const canvas = document.getElementById('wireCanvas');
            const ctx = canvases.wire;
            const lambda = parseFloat(document.getElementById('lambdaSlider').value);
            
            document.getElementById('lambdaValue').textContent = lambda.toFixed(1);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw wire (vertical line in center)
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();

            // Add charges on the wire
            ctx.fillStyle = lambda > 0 ? '#ff4444' : '#4444ff';
            for(let y = 20; y < canvas.height; y += 30) {
                ctx.beginPath();
                ctx.arc(canvas.width/2, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw field lines
            drawWireFieldLines(ctx, canvas, lambda);

            // Draw Gaussian surface if enabled
            if(showGaussian) {
                drawWireGaussianSurface(ctx, canvas);
            }
        }

        function drawWireFieldLines(ctx, canvas, lambda) {
            const centerX = canvas.width / 2;
            const numLines = 12;
            
            ctx.strokeStyle = lambda > 0 ? '#ffeb3b' : '#00bcd4';
            ctx.lineWidth = 2;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines;
                const startR = 20;
                const endR = Math.min(canvas.width, canvas.height) / 3;
                
                // Draw radial field lines
                ctx.beginPath();
                for(let r = startR; r <= endR; r += 2) {
                    const x = centerX + r * Math.cos(angle);
                    const y = canvas.height/2 + r * Math.sin(angle);
                    
                    if(r === startR) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw arrow heads
                const arrowX = centerX + endR * Math.cos(angle);
                const arrowY = canvas.height/2 + endR * Math.sin(angle);
                drawArrowHead(ctx, arrowX, arrowY, angle, lambda > 0);
            }
        }

        function drawWireGaussianSurface(ctx, canvas) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 80;
            
            // Draw cylindrical surface (circle in 2D view)
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function handleWireClick(event) {
            const canvas = document.getElementById('wireCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const centerX = canvas.width / 2;
            const r = Math.abs(x - centerX);
            const lambda = parseFloat(document.getElementById('lambdaSlider').value) * 1e-9; // Convert to C/m
            
            if(r > 0) {
                const E = (lambda) / (2 * Math.PI * epsilon0 * (r/100)); // r in meters (scaled)
                const EMagnitude = Math.abs(E);
                
                document.getElementById('wireFieldValue').textContent = 
                    `E = ${EMagnitude.toExponential(2)} N/C`;
                
                document.getElementById('wirePointInfo').innerHTML = `
                    <strong>Distance from wire:</strong> ${r.toFixed(1)} pixels<br>
                    <strong>Field Direction:</strong> ${lambda > 0 ? 'Outward' : 'Inward'}<br>
                    <strong>Field Magnitude:</strong> ${EMagnitude.toExponential(2)} N/C
                `;
                
                // Highlight the clicked point
                const ctx = canvases.wire;
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Sheet Simulation Functions
        function updateSheetSimulation() {
            const canvas = document.getElementById('sheetCanvas');
            const ctx = canvases.sheet;
            const sigma = parseFloat(document.getElementById('sigmaSlider').value);
            
            document.getElementById('sigmaValue').textContent = sigma.toFixed(1);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sheet (vertical rectangle in center)
            ctx.fillStyle = sigma > 0 ? 'rgba(255,68,68,0.7)' : 'rgba(68,68,255,0.7)';
            ctx.fillRect(canvas.width/2 - 5, 50, 10, canvas.height - 100);
            
            // Add charges on the sheet
            ctx.fillStyle = sigma > 0 ? '#ff4444' : '#4444ff';
            for(let y = 60; y < canvas.height - 50; y += 25) {
                ctx.beginPath();
                ctx.arc(canvas.width/2, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw field lines
            drawSheetFieldLines(ctx, canvas, sigma);

            // Calculate field value
            const E = Math.abs(sigma * 1e-9) / (2 * epsilon0);
            document.getElementById('sheetFieldValue').textContent = 
                `E = ${E.toExponential(2)} N/C`;

            // Draw Gaussian surface if enabled
            if(showGaussian) {
                drawSheetGaussianSurface(ctx, canvas);
            }
        }

        function drawSheetFieldLines(ctx, canvas, sigma) {
            ctx.strokeStyle = sigma > 0 ? '#ffeb3b' : '#00bcd4';
            ctx.lineWidth = 2;
            
            const sheetX = canvas.width / 2;
            const numLines = 8;
            
            // Left side field lines
            for(let i = 0; i < numLines; i++) {
                const y = 80 + (canvas.height - 160) * i / (numLines - 1);
                
                ctx.beginPath();
                ctx.moveTo(sheetX - 100, y);
                ctx.lineTo(sheetX - 20, y);
                ctx.stroke();
                
                // Arrow head
                const direction = sigma > 0 ? -1 : 1;
                drawArrowHead(ctx, sheetX - 20, y, direction * Math.PI, sigma > 0);
            }
            
            // Right side field lines
            for(let i = 0; i < numLines; i++) {
                const y = 80 + (canvas.height - 160) * i / (numLines - 1);
                
                ctx.beginPath();
                ctx.moveTo(sheetX + 20, y);
                ctx.lineTo(sheetX + 100, y);
                ctx.stroke();
                
                // Arrow head
                const direction = sigma > 0 ? 1 : -1;
                drawArrowHead(ctx, sheetX + 100, y, direction * 0, sigma > 0);
            }
        }

        function drawSheetGaussianSurface(ctx, canvas) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            
            const sheetX = canvas.width / 2;
            const boxWidth = 80;
            const boxHeight = 120;
            const centerY = canvas.height / 2;
            
            // Draw rectangular Gaussian surface
            ctx.beginPath();
            ctx.rect(sheetX - boxWidth/2, centerY - boxHeight/2, boxWidth, boxHeight);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function handleSheetClick(event) {
            const canvas = document.getElementById('sheetCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            
            const sheetX = canvas.width / 2;
            const sigma = parseFloat(document.getElementById('sigmaSlider').value) * 1e-9;
            const E = Math.abs(sigma) / (2 * epsilon0);
            
            document.getElementById('sheetPointInfo').innerHTML = `
                <strong>Position:</strong> ${x < sheetX ? 'Left' : 'Right'} of sheet<br>
                <strong>Field Direction:</strong> ${sigma > 0 ? 'Away from sheet' : 'Toward sheet'}<br>
                <strong>Field Magnitude:</strong> ${E.toExponential(2)} N/C (uniform everywhere!)
            `;
            
            // Highlight the clicked point
            const ctx = canvases.sheet;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, event.clientY - rect.top, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Spherical Shell Simulation Functions
        function updateShellSimulation() {
            const canvas = document.getElementById('shellCanvas');
            const ctx = canvases.shell;
            const charge = parseFloat(document.getElementById('chargeSlider').value);
            const radius = parseFloat(document.getElementById('radiusSlider').value);
            
            document.getElementById('chargeValue').textContent = charge.toFixed(1);
            document.getElementById('radiusValue').textContent = radius.toString();
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw shell
            ctx.strokeStyle = charge > 0 ? '#ff4444' : '#4444ff';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add charges on the shell
            const numCharges = 16;
            ctx.fillStyle = charge > 0 ? '#ff4444' : '#4444ff';
            for(let i = 0; i < numCharges; i++) {
                const angle = (2 * Math.PI * i) / numCharges;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw charge symbols
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(charge > 0 ? '+' : '-', x, y + 4);
                ctx.fillStyle = charge > 0 ? '#ff4444' : '#4444ff';
            }

            // Draw field lines
            drawShellFieldLines(ctx, canvas, charge, radius, centerX, centerY);

            // Draw Gaussian surface if enabled
            if(showGaussian) {
                drawShellGaussianSurface(ctx, canvas, centerX, centerY);
            }
        }

        function drawShellFieldLines(ctx, canvas, charge, shellRadius, centerX, centerY) {
            if(charge === 0) return;
            
            ctx.strokeStyle = charge > 0 ? '#ffeb3b' : '#00bcd4';
            ctx.lineWidth = 2;
            
            const numLines = 16;
            const minRadius = shellRadius + 10;
            const maxRadius = Math.min(canvas.width, canvas.height) / 3;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines;
                
                // Only draw outside the shell
                ctx.beginPath();
                for(let r = minRadius; r <= maxRadius; r += 3) {
                    const x = centerX + r * Math.cos(angle);
                    const y = centerY + r * Math.sin(angle);
                    
                    if(r === minRadius) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Draw arrow heads
                const arrowX = centerX + maxRadius * Math.cos(angle);
                const arrowY = centerY + maxRadius * Math.sin(angle);
                drawArrowHead(ctx, arrowX, arrowY, angle, charge > 0);
            }
            
            // Draw text inside shell
            ctx.fillStyle = '#ffeb3b';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('E = 0', centerX, centerY);
            ctx.fillText('(Inside Shell)', centerX, centerY + 20);
        }

        function drawShellGaussianSurface(ctx, canvas, centerX, centerY) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 3;
            ctx.setLineDash([10, 5]);
            
            const gaussianRadius = 120;
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, gaussianRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function handleShellClick(event) {
            const canvas = document.getElementById('shellCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const clickRadius = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
            const shellRadius = parseFloat(document.getElementById('radiusSlider').value);
            const charge = parseFloat(document.getElementById('chargeSlider').value) * 1e-9; // Convert to C
            
            let fieldInfo = '';
            let fieldValue = '';
            
            if(clickRadius < shellRadius) {
                // Inside the shell
                fieldValue = 'E = 0 N/C';
                fieldInfo = `
                    <strong>Position:</strong> Inside shell (r < R)<br>
                    <strong>Distance from center:</strong> ${clickRadius.toFixed(1)} pixels<br>
                    <strong>Shell radius:</strong> ${shellRadius} pixels<br>
                    <strong>Electric field:</strong> Zero (Gauss's law!)
                `;
            } else {
                // Outside the shell
                const r_meters = clickRadius / 100; // Convert to meters (scaled)
                const E = Math.abs(charge) / (4 * Math.PI * epsilon0 * r_meters**2);
                fieldValue = `E = ${E.toExponential(2)} N/C`;
                fieldInfo = `
                    <strong>Position:</strong> Outside shell (r > R)<br>
                    <strong>Distance from center:</strong> ${clickRadius.toFixed(1)} pixels<br>
                    <strong>Shell radius:</strong> ${shellRadius} pixels<br>
                    <strong>Field acts like:</strong> Point charge at center<br>
                    <strong>Field direction:</strong> ${charge > 0 ? 'Radially outward' : 'Radially inward'}
                `;
            }
            
            document.getElementById('shellFieldValue').textContent = fieldValue;
            document.getElementById('shellPointInfo').innerHTML = fieldInfo;
            
            // Highlight the clicked point
            const ctx = canvases.shell;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Atomic Model Simulation Functions
        function updateAtomSimulation() {
            const canvas = document.getElementById('atomCanvas');
            const ctx = canvases.atom;
            const nuclearCharge = parseFloat(document.getElementById('nuclearChargeSlider').value);
            const atomRadius = parseFloat(document.getElementById('atomRadiusSlider').value);
            
            document.getElementById('nuclearChargeValue').textContent = nuclearCharge.toString();
            document.getElementById('atomRadiusValue').textContent = atomRadius.toString();
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw negative charge cloud
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, atomRadius);
            gradient.addColorStop(0, 'rgba(68,68,255,0.3)');
            gradient.addColorStop(1, 'rgba(68,68,255,0.1)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, atomRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw atom boundary
            ctx.strokeStyle = '#4444ff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, atomRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add negative charge symbols
            const numNegCharges = 12;
            ctx.fillStyle = '#4444ff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            for(let i = 0; i < numNegCharges; i++) {
                const angle = (2 * Math.PI * i) / numNegCharges;
                const r = atomRadius * 0.7;
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                ctx.fillText('-', x, y + 4);
            }
            
            // Draw nucleus
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            
            // Nucleus label
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 10px Arial';
            ctx.fillText('+', centerX, centerY + 3);
            
            // Draw field lines
            drawAtomFieldLines(ctx, canvas, nuclearCharge, atomRadius, centerX, centerY);
        }

        function drawAtomFieldLines(ctx, canvas, nuclearCharge, atomRadius, centerX, centerY) {
            const numLines = 12;
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 2;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines;
                
                // Field lines inside atom (complex behavior)
                ctx.beginPath();
                const steps = 30;
                for(let j = 0; j <= steps; j++) {
                    const r = (atomRadius * j) / steps;
                    
                    if(r < 5) continue; // Skip very close to nucleus
                    
                    // Simplified field representation
                    const fieldStrength = Math.max(0, 1 - r/(atomRadius * 0.8));
                    const x = centerX + r * Math.cos(angle) * (0.8 + 0.2 * fieldStrength);
                    const y = centerY + r * Math.sin(angle) * (0.8 + 0.2 * fieldStrength);
                    
                    if(j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            // Show field is zero outside
            ctx.fillStyle = '#ffeb3b';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('E = 0', centerX + atomRadius + 30, centerY - 20);
            ctx.fillText('(Outside)', centerX + atomRadius + 30, centerY);
        }

        function handleAtomClick(event) {
            const canvas = document.getElementById('atomCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const clickRadius = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
            const atomRadius = parseFloat(document.getElementById('atomRadiusSlider').value);
            const Ze = parseFloat(document.getElementById('nuclearChargeSlider').value);
            
            let fieldInfo = '';
            let fieldValue = '';
            
            if(clickRadius < atomRadius && clickRadius > 5) {
                // Inside the atom
                const r = clickRadius / 100; // Convert to meters (scaled)
                const R = atomRadius / 100;
                const e = 1.6e-19; // Elementary charge
                
                // E = (Ze/4œÄŒµ‚ÇÄ) √ó (1/r¬≤ - r/R¬≥)
                const term1 = 1 / (r**2);
                const term2 = r / (R**3);
                const E = (Ze * e / (4 * Math.PI * epsilon0)) * (term1 - term2);
                
                fieldValue = `E = ${Math.abs(E).toExponential(2)} N/C`;
                fieldInfo = `
                    <strong>Position:</strong> Inside atom (r < R)<br>
                    <strong>Distance from nucleus:</strong> ${clickRadius.toFixed(1)} pixels<br>
                    <strong>Atom radius:</strong> ${atomRadius} pixels<br>
                    <strong>Field equation:</strong> E = (Ze/4œÄŒµ‚ÇÄ)(1/r¬≤ - r/R¬≥)<br>
                    <strong>Nuclear charge:</strong> +${Ze}e
                `;
            } else if(clickRadius >= atomRadius) {
                // Outside the atom
                fieldValue = 'E = 0 N/C';
                fieldInfo = `
                    <strong>Position:</strong> Outside atom (r > R)<br>
                    <strong>Distance from nucleus:</strong> ${clickRadius.toFixed(1)} pixels<br>
                    <strong>Atom radius:</strong> ${atomRadius} pixels<br>
                    <strong>Total charge:</strong> 0 (neutral atom)<br>
                    <strong>Electric field:</strong> Zero everywhere outside
                `;
            } else {
                // Very close to nucleus
                fieldValue = 'E ‚Üí ‚àû';
                fieldInfo = `
                    <strong>Position:</strong> Very close to nucleus<br>
                    <strong>Note:</strong> Field becomes very large near point charge
                `;
            }
            
            document.getElementById('atomFieldValue').textContent = fieldValue;
            document.getElementById('atomPointInfo').innerHTML = fieldInfo;
            
            // Highlight the clicked point
            const ctx = canvases.atom;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // Utility Functions
        function drawArrowHead(ctx, x, y, angle, outward) {
            const headLength = 8;
            const headAngle = Math.PI / 6;
            
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(outward ? angle : angle + Math.PI);
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-headLength * Math.cos(headAngle), -headLength * Math.sin(headAngle));
            ctx.moveTo(0, 0);
            ctx.lineTo(-headLength * Math.cos(headAngle), headLength * Math.sin(headAngle));
            ctx.stroke();
            
            ctx.restore();
        }

        function animateFieldLines(type) {
            if(animating) return;
            animating = true;
            
            let animationFrame = 0;
            const maxFrames = 60; // 3 seconds at 20fps
            
            function animate() {
                // Update the current simulation with animation effects
                switch(type) {
                    case 'wire': animateWireField(animationFrame); break;
                    case 'sheet': animateSheetField(animationFrame); break;
                    case 'shell': animateShellField(animationFrame); break;
                    case 'atom': animateAtomField(animationFrame); break;
                }
                
                animationFrame++;
                if(animationFrame < maxFrames) {
                    setTimeout(animate, 50); // 20fps
                } else {
                    animating = false;
                    // Reset to normal view
                    switch(type) {
                        case 'wire': updateWireSimulation(); break;
                        case 'sheet': updateSheetSimulation(); break;
                        case 'shell': updateShellSimulation(); break;
                        case 'atom': updateAtomSimulation(); break;
                    }
                }
            }
            
            animate();
        }

        function animateWireField(frame) {
            const canvas = document.getElementById('wireCanvas');
            const ctx = canvases.wire;
            const lambda = parseFloat(document.getElementById('lambdaSlider').value);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw wire with pulsing effect
            const pulseIntensity = 0.8 + 0.4 * Math.sin(frame * 0.3);
            ctx.strokeStyle = lambda > 0 ? `rgba(255,68,68,${pulseIntensity})` : `rgba(68,68,255,${pulseIntensity})`;
            ctx.lineWidth = 4 + 2 * Math.sin(frame * 0.2);
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, 0);
            ctx.lineTo(canvas.width/2, canvas.height);
            ctx.stroke();

            // Add animated charges
            ctx.fillStyle = lambda > 0 ? '#ff4444' : '#4444ff';
            for(let y = 20; y < canvas.height; y += 30) {
                const chargeSize = 3 + 2 * Math.sin(frame * 0.4 + y * 0.1);
                ctx.beginPath();
                ctx.arc(canvas.width/2, y, chargeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw animated field lines
            drawAnimatedWireFieldLines(ctx, canvas, lambda, frame);

            if(showGaussian) {
                drawAnimatedGaussianSurface(ctx, canvas, frame, 'cylinder');
            }
        }

        function drawAnimatedWireFieldLines(ctx, canvas, lambda, frame) {
            const centerX = canvas.width / 2;
            const numLines = 12;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines;
                const animationOffset = frame * 0.1;
                
                // Pulsing color
                const intensity = 0.6 + 0.4 * Math.sin(frame * 0.3 + i * 0.5);
                ctx.strokeStyle = lambda > 0 ? 
                    `rgba(255,235,59,${intensity})` : 
                    `rgba(0,188,212,${intensity})`;
                ctx.lineWidth = 2 + Math.sin(frame * 0.2 + i) * 0.5;
                
                // Animated field lines that grow and pulse
                const maxRadius = (Math.min(canvas.width, canvas.height) / 3) * (0.5 + 0.5 * Math.sin(frame * 0.1 + i * 0.3));
                const startR = 20;
                
                ctx.beginPath();
                for(let r = startR; r <= maxRadius; r += 3) {
                    const wobble = 2 * Math.sin(frame * 0.2 + r * 0.05);
                    const x = centerX + (r + wobble) * Math.cos(angle + animationOffset);
                    const y = canvas.height/2 + (r + wobble) * Math.sin(angle + animationOffset);
                    
                    if(r === startR) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Animated arrow heads
                const arrowX = centerX + maxRadius * Math.cos(angle + animationOffset);
                const arrowY = canvas.height/2 + maxRadius * Math.sin(angle + animationOffset);
                drawAnimatedArrowHead(ctx, arrowX, arrowY, angle + animationOffset, lambda > 0, frame);
            }
        }

        function animateSheetField(frame) {
            const canvas = document.getElementById('sheetCanvas');
            const ctx = canvases.sheet;
            const sigma = parseFloat(document.getElementById('sigmaSlider').value);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw animated sheet
            const pulseIntensity = 0.5 + 0.3 * Math.sin(frame * 0.3);
            ctx.fillStyle = sigma > 0 ? 
                `rgba(255,68,68,${pulseIntensity})` : 
                `rgba(68,68,255,${pulseIntensity})`;
            ctx.fillRect(canvas.width/2 - 5, 50, 10, canvas.height - 100);
            
            // Add animated charges
            ctx.fillStyle = sigma > 0 ? '#ff4444' : '#4444ff';
            for(let y = 60; y < canvas.height - 50; y += 25) {
                const chargeSize = 3 + 1.5 * Math.sin(frame * 0.4 + y * 0.1);
                ctx.beginPath();
                ctx.arc(canvas.width/2, y, chargeSize, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw animated field lines
            drawAnimatedSheetFieldLines(ctx, canvas, sigma, frame);

            if(showGaussian) {
                drawAnimatedGaussianSurface(ctx, canvas, frame, 'box');
            }
        }

        function drawAnimatedSheetFieldLines(ctx, canvas, sigma, frame) {
            const sheetX = canvas.width / 2;
            const numLines = 8;
            
            for(let i = 0; i < numLines; i++) {
                const y = 80 + (canvas.height - 160) * i / (numLines - 1);
                const animationOffset = frame * 0.05;
                
                // Pulsing color and width
                const intensity = 0.6 + 0.4 * Math.sin(frame * 0.3 + i * 0.3);
                ctx.strokeStyle = sigma > 0 ? 
                    `rgba(255,235,59,${intensity})` : 
                    `rgba(0,188,212,${intensity})`;
                ctx.lineWidth = 2 + Math.sin(frame * 0.2 + i) * 0.5;
                
                // Left side animated field lines
                const leftLength = 80 + 20 * Math.sin(frame * 0.1 + i * 0.2);
                ctx.beginPath();
                ctx.moveTo(sheetX - leftLength, y + Math.sin(frame * 0.15 + i) * 2);
                ctx.lineTo(sheetX - 20, y);
                ctx.stroke();
                
                // Right side animated field lines
                const rightLength = 80 + 20 * Math.sin(frame * 0.1 + i * 0.2 + Math.PI);
                ctx.beginPath();
                ctx.moveTo(sheetX + 20, y);
                ctx.lineTo(sheetX + rightLength, y + Math.sin(frame * 0.15 + i + Math.PI) * 2);
                ctx.stroke();
                
                // Animated arrow heads
                drawAnimatedArrowHead(ctx, sheetX - 20, y, sigma > 0 ? -Math.PI : 0, sigma > 0, frame);
                drawAnimatedArrowHead(ctx, sheetX + rightLength, y + Math.sin(frame * 0.15 + i + Math.PI) * 2, sigma > 0 ? 0 : Math.PI, sigma > 0, frame);
            }
        }

        function animateShellField(frame) {
            const canvas = document.getElementById('shellCanvas');
            const ctx = canvases.shell;
            const charge = parseFloat(document.getElementById('chargeSlider').value);
            const radius = parseFloat(document.getElementById('radiusSlider').value);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw animated shell
            const pulseRadius = radius + 3 * Math.sin(frame * 0.3);
            ctx.strokeStyle = charge > 0 ? '#ff4444' : '#4444ff';
            ctx.lineWidth = 4 + 2 * Math.sin(frame * 0.2);
            ctx.beginPath();
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Add animated charges
            const numCharges = 16;
            ctx.fillStyle = charge > 0 ? '#ff4444' : '#4444ff';
            for(let i = 0; i < numCharges; i++) {
                const angle = (2 * Math.PI * i) / numCharges + frame * 0.02;
                const x = centerX + pulseRadius * Math.cos(angle);
                const y = centerY + pulseRadius * Math.sin(angle);
                
                const chargeSize = 4 + 2 * Math.sin(frame * 0.4 + i * 0.3);
                ctx.beginPath();
                ctx.arc(x, y, chargeSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Animated charge symbols
                ctx.fillStyle = '#ffffff';
                ctx.font = `${12 + 2 * Math.sin(frame * 0.3)}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(charge > 0 ? '+' : '-', x, y + 4);
                ctx.fillStyle = charge > 0 ? '#ff4444' : '#4444ff';
            }

            // Draw animated field lines
            drawAnimatedShellFieldLines(ctx, canvas, charge, radius, centerX, centerY, frame);

            if(showGaussian) {
                drawAnimatedGaussianSurface(ctx, canvas, frame, 'sphere');
            }
        }

        function drawAnimatedShellFieldLines(ctx, canvas, charge, shellRadius, centerX, centerY, frame) {
            if(charge === 0) return;
            
            const numLines = 16;
            const minRadius = shellRadius + 10;
            const maxRadius = Math.min(canvas.width, canvas.height) / 3;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines + frame * 0.01;
                
                // Pulsing color
                const intensity = 0.6 + 0.4 * Math.sin(frame * 0.3 + i * 0.2);
                ctx.strokeStyle = charge > 0 ? 
                    `rgba(255,235,59,${intensity})` : 
                    `rgba(0,188,212,${intensity})`;
                ctx.lineWidth = 2 + Math.sin(frame * 0.2 + i) * 0.5;
                
                // Animated field lines
                const animatedMaxRadius = maxRadius * (0.7 + 0.3 * Math.sin(frame * 0.1 + i * 0.1));
                
                ctx.beginPath();
                for(let r = minRadius; r <= animatedMaxRadius; r += 4) {
                    const wobble = 1 * Math.sin(frame * 0.3 + r * 0.02);
                    const x = centerX + (r + wobble) * Math.cos(angle);
                    const y = centerY + (r + wobble) * Math.sin(angle);
                    
                    if(r === minRadius) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Animated arrow heads
                const arrowX = centerX + animatedMaxRadius * Math.cos(angle);
                const arrowY = centerY + animatedMaxRadius * Math.sin(angle);
                drawAnimatedArrowHead(ctx, arrowX, arrowY, angle, charge > 0, frame);
            }
            
            // Animated text inside shell
            const textIntensity = 0.7 + 0.3 * Math.sin(frame * 0.4);
            ctx.fillStyle = `rgba(255,235,59,${textIntensity})`;
            ctx.font = `bold ${16 + 2 * Math.sin(frame * 0.3)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('E = 0', centerX, centerY);
            ctx.fillText('(Inside Shell)', centerX, centerY + 20);
        }

        function animateAtomField(frame) {
            const canvas = document.getElementById('atomCanvas');
            const ctx = canvases.atom;
            const nuclearCharge = parseFloat(document.getElementById('nuclearChargeSlider').value);
            const atomRadius = parseFloat(document.getElementById('atomRadiusSlider').value);
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Draw animated negative charge cloud
            const pulseRadius = atomRadius + 5 * Math.sin(frame * 0.2);
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, pulseRadius);
            const intensity = 0.2 + 0.1 * Math.sin(frame * 0.3);
            gradient.addColorStop(0, `rgba(68,68,255,${intensity + 0.1})`);
            gradient.addColorStop(1, `rgba(68,68,255,${intensity})`);
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw animated boundary
            ctx.strokeStyle = '#4444ff';
            ctx.lineWidth = 2 + Math.sin(frame * 0.2);
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, pulseRadius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Add animated negative charges
            const numNegCharges = 12;
            ctx.fillStyle = '#4444ff';
            ctx.font = `${12 + 2 * Math.sin(frame * 0.3)}px Arial`;
            ctx.textAlign = 'center';
            for(let i = 0; i < numNegCharges; i++) {
                const angle = (2 * Math.PI * i) / numNegCharges + frame * 0.02;
                const r = pulseRadius * 0.7;
                const x = centerX + r * Math.cos(angle);
                const y = centerY + r * Math.sin(angle);
                ctx.fillText('-', x, y + 4);
            }
            
            // Draw animated nucleus
            const nucleusSize = 8 + 2 * Math.sin(frame * 0.4);
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.arc(centerX, centerY, nucleusSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Nucleus label
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${10 + Math.sin(frame * 0.3)}px Arial`;
            ctx.fillText('+', centerX, centerY + 3);
            
            // Draw animated field lines
            drawAnimatedAtomFieldLines(ctx, canvas, nuclearCharge, atomRadius, centerX, centerY, frame);
        }

        function drawAnimatedAtomFieldLines(ctx, canvas, nuclearCharge, atomRadius, centerX, centerY, frame) {
            const numLines = 12;
            
            for(let i = 0; i < numLines; i++) {
                const angle = (2 * Math.PI * i) / numLines + frame * 0.01;
                
                // Pulsing color
                const intensity = 0.6 + 0.4 * Math.sin(frame * 0.3 + i * 0.2);
                ctx.strokeStyle = `rgba(255,235,59,${intensity})`;
                ctx.lineWidth = 2 + Math.sin(frame * 0.2 + i) * 0.5;
                
                // Complex animated field lines inside atom
                ctx.beginPath();
                const steps = 30;
                for(let j = 0; j <= steps; j++) {
                    const r = (atomRadius * j) / steps;
                    
                    if(r < 5) continue;
                    
                    const fieldStrength = Math.max(0, 1 - r/(atomRadius * 0.8));
                    const wobble = 2 * Math.sin(frame * 0.2 + r * 0.05);
                    const x = centerX + (r + wobble) * Math.cos(angle) * (0.8 + 0.2 * fieldStrength);
                    const y = centerY + (r + wobble) * Math.sin(angle) * (0.8 + 0.2 * fieldStrength);
                    
                    if(j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            // Animated text outside
            const textIntensity = 0.7 + 0.3 * Math.sin(frame * 0.4);
            ctx.fillStyle = `rgba(255,235,59,${textIntensity})`;
            ctx.font = `bold ${14 + 2 * Math.sin(frame * 0.3)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('E = 0', centerX + atomRadius + 30, centerY - 20);
            ctx.fillText('(Outside)', centerX + atomRadius + 30, centerY);
        }

        function drawAnimatedArrowHead(ctx, x, y, angle, outward, frame) {
            const headLength = 8 + 2 * Math.sin(frame * 0.3);
            const headAngle = Math.PI / 6;
            const pulseIntensity = 0.7 + 0.3 * Math.sin(frame * 0.4);
            
            ctx.save();
            ctx.globalAlpha = pulseIntensity;
            ctx.translate(x, y);
            ctx.rotate(outward ? angle : angle + Math.PI);
            
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-headLength * Math.cos(headAngle), -headLength * Math.sin(headAngle));
            ctx.moveTo(0, 0);
            ctx.lineTo(-headLength * Math.cos(headAngle), headLength * Math.sin(headAngle));
            ctx.stroke();
            
            ctx.restore();
        }

        function drawAnimatedGaussianSurface(ctx, canvas, frame, type) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Pulsing green color
            const intensity = 0.6 + 0.4 * Math.sin(frame * 0.4);
            ctx.strokeStyle = `rgba(0,255,0,${intensity})`;
            ctx.lineWidth = 3 + Math.sin(frame * 0.3);
            ctx.setLineDash([10 + 5 * Math.sin(frame * 0.2), 5]);
            
            if(type === 'cylinder') {
                const radius = 80 + 10 * Math.sin(frame * 0.2);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            } else if(type === 'box') {
                const boxWidth = 80 + 10 * Math.sin(frame * 0.2);
                const boxHeight = 120 + 15 * Math.sin(frame * 0.15);
                ctx.beginPath();
                ctx.rect(centerX - boxWidth/2, centerY - boxHeight/2, boxWidth, boxHeight);
                ctx.stroke();
            } else if(type === 'sphere') {
                const radius = 120 + 15 * Math.sin(frame * 0.2);
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }

        function toggleGaussianSurface(type) {
            showGaussian = !showGaussian;
            
            switch(type) {
                case 'wire': updateWireSimulation(); break;
                case 'sheet': updateSheetSimulation(); break;
                case 'shell': updateShellSimulation(); break;
                case 'atom': updateAtomSimulation(); break;
            }
        }

        function showFieldGraph() {
            // Create a popup with field vs distance graph for atomic model
            const nuclearCharge = parseFloat(document.getElementById('nuclearChargeSlider').value);
            const atomRadius = parseFloat(document.getElementById('atomRadiusSlider').value);
            
            alert(`Field Graph Feature:\n\nInside atom (r < R): E decreases from center\nAt boundary (r = R): E = 0\nOutside atom (r > R): E = 0\n\nThis demonstrates the unique field behavior in Thomson's atomic model!`);
        }

        // Quiz Functions
        const quizData = [
            {
                question: "For an infinite charged wire, how does the electric field depend on distance?",
                options: ["E ‚àù 1/r", "E ‚àù 1/r¬≤", "E ‚àù r", "E is constant"],
                correct: 0,
                explanation: "For an infinite wire, E = Œª/(2œÄŒµ‚ÇÄr), so E ‚àù 1/r"
            },
            {
                question: "What is unique about the electric field of an infinite charged sheet?",
                options: ["E ‚àù 1/r¬≤", "E ‚àù 1/r", "E is constant", "E ‚àù r"],
                correct: 2,
                explanation: "The field E = œÉ/(2Œµ‚ÇÄ) is independent of distance from the sheet"
            },
            {
                question: "Inside a uniformly charged spherical shell, the electric field is:",
                options: ["Maximum", "Minimum", "Zero", "Varies with position"],
                correct: 2,
                explanation: "By Gauss's law, E = 0 inside because no charge is enclosed"
            },
            {
                question: "In Thomson's atomic model, the electric field outside the atom is:",
                options: ["Very large", "Proportional to 1/r¬≤", "Zero", "Constant"],
                correct: 2,
                explanation: "The atom is neutral overall, so E = 0 outside"
            },
            {
                question: "Which Gaussian surface is most appropriate for finding the field of a long charged wire?",
                options: ["Sphere", "Cube", "Cylinder", "Plane"],
                correct: 2,
                explanation: "A cylindrical surface matches the symmetry of the wire"
            }
        ];

        let currentQuestion = 0;
        let score = 0;
        let quizStarted = false;

        function loadQuiz() {
            if(!quizStarted) {
                currentQuestion = 0;
                score = 0;
                quizStarted = true;
                showQuestion();
            } else {
                // Reset quiz
                quizStarted = false;
                document.getElementById('quizContent').innerHTML = '';
                document.getElementById('quizResults').innerHTML = '';
                loadQuiz();
            }
        }

        function showQuestion() {
            if(currentQuestion >= quizData.length) {
                showQuizResults();
                return;
            }
            
            const quiz = quizData[currentQuestion];
            const quizHTML = `
                <div class="quiz-question">
                    <h3>Question ${currentQuestion + 1} of ${quizData.length}</h3>
                    <p><strong>${quiz.question}</strong></p>
                </div>
                <div class="quiz-options">
                    ${quiz.options.map((option, index) => 
                        `<div class="quiz-option" onclick="selectAnswer(${index})">${option}</div>`
                    ).join('')}
                </div>
                <div id="questionFeedback"></div>
            `;
            
            document.getElementById('quizContent').innerHTML = quizHTML;
        }

        function selectAnswer(selectedIndex) {
            const quiz = quizData[currentQuestion];
            const options = document.querySelectorAll('.quiz-option');
            
            // Disable all options
            options.forEach((option, index) => {
                option.style.pointerEvents = 'none';
                if(index === quiz.correct) {
                    option.classList.add('correct');
                } else if(index === selectedIndex && index !== quiz.correct) {
                    option.classList.add('incorrect');
                }
            });
            
            // Show explanation
            const isCorrect = selectedIndex === quiz.correct;
            if(isCorrect) score++;
            
            document.getElementById('questionFeedback').innerHTML = `
                <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 10px;">
                    <p><strong>${isCorrect ? '‚úÖ Correct!' : '‚ùå Incorrect'}</strong></p>
                    <p>${quiz.explanation}</p>
                    <button class="btn" onclick="nextQuestion()" style="margin-top: 10px;">
                        ${currentQuestion < quizData.length - 1 ? 'Next Question' : 'Show Results'}
                    </button>
                </div>
            `;
        }

        function nextQuestion() {
            currentQuestion++;
            showQuestion();
        }

        function showQuizResults() {
            const percentage = Math.round((score / quizData.length) * 100);
            let message = '';
            
            if(percentage >= 80) {
                message = 'üéâ Excellent! You have mastered Gauss\'s Law!';
            } else if(percentage >= 60) {
                message = 'üëç Good job! Review the concepts and try again.';
            } else {
                message = 'üìö Keep studying! Practice with the simulations above.';
            }
            
            document.getElementById('quizContent').innerHTML = `
                <div style="text-align: center; padding: 30px;">
                    <h2>Quiz Complete!</h2>
                    <div style="font-size: 3em; margin: 20px 0;">${percentage}%</div>
                    <p><strong>You scored ${score} out of ${quizData.length}</strong></p>
                    <p>${message}</p>
                    <button class="btn" onclick="loadQuiz()" style="margin-top: 20px;">Retake Quiz</button>
                </div>
            `;
            
            quizStarted = false;
        }

        // Initialize first simulation
        setTimeout(() => {
            updateWireSimulation();
            updateSheetSimulation();
            updateShellSimulation();
            updateAtomSimulation();
        }, 100);
    </script>
</body>
</html>
